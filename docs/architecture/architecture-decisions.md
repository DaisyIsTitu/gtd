# 아키텍처 결정 기록 (ADR)
# Todo Time-blocking 앱

## 요약

이 문서는 Todo Time-blocking 애플리케이션을 위한 주요 아키텍처 결정사항들을 기록합니다. 기술 선택, 설계 패턴, 시스템 설계 근거를 포함합니다.

## 기술 스택 결정

### ADR-001: 프론트엔드 프레임워크 - NextJS + TypeScript

**상태**: 승인됨

**배경**: 서버 사이드 렌더링 기능을 가진 반응형 캘린더 인터페이스 구축을 위한 현대적인 웹 프레임워크가 필요합니다.

**결정**: NextJS와 TypeScript 사용

**근거**:
- **NextJS**: 성능과 SEO 향상을 위한 우수한 SSR/SSG 기능 제공
- **TypeScript**: 복잡한 캘린더 작업과 상태 관리를 위한 타입 안전성 보장
- **React 생태계**: 캘린더 및 드래그앤드롭 기능을 위한 풍부한 컴포넌트 라이브러리
- **성능**: 웹 바이탈 및 사용자 경험을 위한 내장 최적화

**고려된 대안**:
- Vue.js + Nuxt.js: 좋은 프레임워크지만 캘린더 컴포넌트 생태계가 작음
- Angular: 캘린더 앱용으로는 너무 무겁고 과도하게 엔지니어링됨

### ADR-002: 백엔드 프레임워크 - Spring Boot + Kotlin

**상태**: 승인됨

**배경**: 복잡한 스케줄링 알고리즘과 Google API 연동을 위한 견고한 백엔드 프레임워크가 필요합니다.

**결정**: Spring Boot와 Kotlin 사용

**근거**:
- **Spring Boot**: 우수한 의존성 주입 및 설정을 가진 엔터프라이즈급 프레임워크
- **Kotlin**: 스케줄링 로직과 API 연동에 완벽한 null 안전성을 가진 현대적 언어
- **Spring Security**: Google 인증을 위한 내장 OAuth 2.0 지원
- **Spring Data JPA**: 복잡한 데이터베이스 관계를 위한 우수한 ORM 기능
- **생태계**: 백그라운드 작업, 모니터링, 클라우드 배포를 위한 풍부한 생태계

**고려된 대안**:
- Node.js + Express: JavaScript 런타임 일관성이 있지만 복잡한 스케줄링 알고리즘에는 적합하지 않음
- Java + Spring: Kotlin에 비해 장황한 문법, 개발자 생산성 낮음

### ADR-003: 데이터베이스 - PostgreSQL

**상태**: 승인됨

**배경**: ACID 준수로 복잡한 스케줄링 데이터를 위한 신뢰할 수 있는 데이터베이스가 필요합니다.

**결정**: PostgreSQL 사용

**근거**:
- **ACID 준수**: 할일 상태 전환과 캘린더 동기화에 중요
- **복잡한 쿼리**: 스케줄링 최적화 알고리즘을 위한 고급 SQL 지원
- **JSON 지원**: 스키마 마이그레이션 없이 유연한 할일 메타데이터 저장 가능
- **확장성**: 읽기 중심의 캘린더 작업을 위한 우수한 성능
- **시간대 지원**: 지역 간 스케줄링을 위한 내장 시간대 처리

**고려된 대안**:
- MongoDB: NoSQL의 장점이 있지만 스케줄링 일관성에 필요한 ACID 준수 부족
- MySQL: 좋은 성능이지만 복잡한 JSON 작업과 시간대에 대한 지원이 약함

## 아키텍처 패턴 결정

### ADR-004: 통신 패턴 - REST API (WebSocket/SSE 사용 안함)

**상태**: 승인됨

**배경**: 사용자가 WebSocket/SSE 사용을 금지하도록 명시적으로 요청했습니다.

**결정**: 폴링과 백그라운드 작업을 사용한 REST API 사용

**근거**:
- **단순성**: REST API는 디버깅, 테스트, 모니터링이 더 쉬움
- **캐싱**: 캘린더 데이터를 위한 더 나은 HTTP 캐싱 전략
- **백그라운드 작업**: 스케줄 작업이 시간에 민감한 작업(놓친 할일) 처리
- **상태 없음**: 세션 친화성 없이 수평 확장 가능

**트레이드오프**:
- 실시간 업데이트에는 폴링 또는 수동 새로 고침 필요
- 상태 변경에 대한 지연 시간이 약간 높음

### ADR-005: 서비스 아키텍처 - 계층형 + 서비스 지향

**상태**: 승인됨

**배경**: 복잡한 비즈니스 로직을 위한 명확한 관심사 분리가 필요합니다.

**결정**: 서비스 지향 설계로 계층형 아키텍처 구현

**근거**:
- **계층형 아키텍처**: 프레젠테이션, 비즈니스, 데이터 레이어 간의 명확한 분리
- **서비스 지향**: 각 핵심 서비스에 대한 단일 책임 원칙
- **테스트 가능성**: 개별 서비스를 독립적으로 단위 테스트하기 쉬움
- **유지보수성**: 명확한 경계로 코드를 이해하고 수정하기 쉬움

**식별된 서비스**:
- TodoService: 할일 생명주기 관리
- SchedulingService: 스마트 스케줄링 알고리즘
- GoogleCalendarService: 외부 API 연동
- TimeSlotAnalyzer: 시간 분석 로직
- TodoStateManager: 상태 머신 관리

### ADR-006: 상태 관리 - 서버 사이드 상태 머신

**상태**: 승인됨

**배경**: 할일 상태는 일관성이 있어야 하는 중요한 비즈니스 로직입니다.

**결정**: 데이터베이스 지속성을 통한 백엔드에서 상태 관리 구현

**근거**:
- **일관성**: 할일 상태에 대한 단일 진실 소스
- **비즈니스 규칙**: 복잡한 상태 전환 로직은 비즈니스 레이어에 속함
- **신뢰성**: 데이터베이스 트랜잭션이 상태 일관성 보장
- **감사 추적**: 디버깅 및 분석을 위한 상태 변경 추적 가능

**상태 전환**:
```
대기중 → 예약됨 → 진행중 → 완료
       ↓         ↓
    취소됨 ← 놓침 (자동 감지)
```

## 연동 결정

### ADR-007: Google Calendar 연동 - 읽기/쓰기 API 접근

**상태**: 승인됨

**배경**: 핵심 기능이 양방향 Google Calendar 동기화를 요구합니다.

**결정**: 읽기/쓰기 권한으로 Google Calendar API 사용

**근거**:
- **실시간 가용성**: 캘린더 이벤트를 읽어 빈 시간 슬롯 찾기
- **자동 차단**: 할일 일정을 Google Calendar에 다시 쓰기
- **충돌 감지**: 기존 이벤트를 확인하여 이중 예약 방지
- **사용자 경험**: 사용자의 기존 캘린더 워크플로우와 원활한 연동

**구현 전략**:
- 안전한 인증을 위한 OAuth 2.0
- 외부 캘린더 변경 처리를 위한 주기적 동기화 작업
- 사용자 알림과 충돌 해결

### ADR-008: 인증 - Google OAuth 2.0만 사용

**상태**: 승인됨

**배경**: 애플리케이션이 Google Calendar와 밀접하게 연동됩니다.

**결정**: 단일 사인온 방법으로 Google OAuth 2.0 사용

**근거**:
- **원활한 경험**: 사용자가 이미 캘린더 접근을 위해 Google 계정 필요
- **보안**: Google의 견고한 인증 인프라 활용
- **복잡성 감소**: 별도의 사용자 등록/비밀번호 관리 불필요
- **API 접근**: 앱 접근과 Google API 모두를 위한 단일 인증 플로우

**트레이드오프**:
- Google 서비스에 대한 의존성
- Google 계정이 없는 사용자 지원 불가

## 성능 & 확장성 결정

### ADR-009: 스케줄링 알고리즘 - 시간 슬롯 매트릭스 접근법

**상태**: 승인됨

**배경**: 최적의 할일 배치를 찾기 위한 효율적인 알고리즘이 필요합니다.

**결정**: 30분 단위로 시간 슬롯 매트릭스 구현

**근거**:
- **효율성**: 사전 계산된 매트릭스로 O(1) 충돌 감지 가능
- **유연성**: 30분 슬롯이 정밀도와 성능 간의 좋은 균형 제공
- **최적화**: 매트릭스에서 다양한 알고리즘(탐욕적, 우선순위 기반) 적용 가능
- **확장성**: 매트릭스 크기가 업무 시간에 의해 제한됨 (10시간 × 5일 = 100슬롯)

**알고리즘 전략**:
1. Google Calendar에서 가용성 매트릭스 구축
2. 우선순위 및 마감일 제약을 사용한 할일 배치 적용
3. 단일 슬롯에 맞지 않는 할일에 대한 분할 처리

### ADR-010: 백그라운드 작업 - Cron 기반 스케줄링

**상태**: 승인됨

**배경**: 놓친 할일 감지 및 캘린더 동기화를 위한 자동화된 프로세스가 필요합니다.

**결정**: 백그라운드 작업을 위해 Spring의 @Scheduled 어노테이션 사용

**근거**:
- **단순성**: 내장된 Spring Boot 기능, 외부 의존성 없음
- **신뢰성**: 서비스에 대한 전체 접근 권한으로 애플리케이션 컨텍스트 내에서 작업 실행
- **모니터링**: 작업 실행을 위한 메트릭 및 로깅 추가 쉬움
- **확장성**: 클러스터된 배포에서 단일 인스턴스에서 실행되도록 작업 구성 가능

**작업 일정**:
- 놓친 할일 감지: 매 30분마다
- 캘린더 동기화: 매 15분마다
- 데이터 정리: 매일 자정

## 보안 결정

### ADR-011: API 보안 - JWT + OAuth 2.0

**상태**: 승인됨

**배경**: 사용자 컨텍스트로 안전한 API 엔드포인트가 필요합니다.

**결정**: API 인증을 위해 Google OAuth의 JWT 토큰 사용

**근거**:
- **상태 없음**: JWT 토큰으로 인스턴스 간 상태 없는 인증 가능
- **연동**: Google OAuth 플로우와 원활한 연동
- **성능**: 토큰 검증을 위한 데이터베이스 조회 불필요
- **표준**: API 보안을 위한 업계 표준 접근법

**보안 조치**:
- 모든 곳에서 HTTPS
- 프론트엔드 도메인을 위한 CORS 구성
- 모든 보호된 엔드포인트에서 JWT 토큰 검증
- API 엔드포인트 속도 제한

## 데이터 설계 결정

### ADR-012: 데이터베이스 스키마 - JSON 확장을 사용한 정규화

**상태**: 승인됨

**배경**: 메타데이터의 유연성을 위해 쿼리를 위한 구조화된 데이터가 필요합니다.

**결정**: 유연한 데이터를 위해 PostgreSQL JSON 컬럼과 정규화된 테이블 사용

**근거**:
- **쿼리 성능**: 정규화된 구조로 효율적인 JOIN 작업 가능
- **유연성**: JSON 컬럼으로 스키마 변경 없이 가변 할일 메타데이터 저장 가능
- **데이터 무결성**: 외래 키 제약으로 참조 무결성 보장
- **미래 보장**: 데이터베이스 마이그레이션 없이 할일 속성 발전 가능

**주요 테이블**:
- users: Google 연동을 포함한 핵심 사용자 데이터
- todos: 구조화된 필드 + JSON 메타데이터를 포함한 할일 엔티티
- todo_scheduling: 분할 관계를 포함한 예약된 시간 슬롯
- calendar_sync: 동기화 추적 및 메타데이터

## 배포 & 운영 결정

### ADR-013: 배포 전략 - 관리형 서비스를 사용한 컨테이너 기반

**상태**: 승인됨

**배경**: 확장 가능하고 유지 관리 가능한 배포 접근법이 필요합니다.

**결정**: 관리형 데이터베이스 및 CDN과 함께 컨테이너화된 백엔드 사용

**근거**:
- **확장성**: 컨테이너 오케스트레이션으로 수평 확장 가능
- **신뢰성**: 관리형 데이터베이스로 운영 오버헤드 감소
- **성능**: CDN이 전 세계적으로 프론트엔드 로딩 시간 개선
- **비용**: 관리형 서비스가 비용 대비 운영 복잡성 최적화

**배포 아키텍처**:
- 프론트엔드: Vercel 또는 유사한 플랫폼의 NextJS
- 백엔드: 클라우드 플랫폼의 Docker 컨테이너 (AWS ECS/GKE)
- 데이터베이스: 관리형 PostgreSQL (RDS/Cloud SQL)
- CDN: 정적 자산을 위한 CloudFront/CloudFlare

## 모니터링 & 관찰 가능성

### ADR-014: 관찰 가능성 전략 - 구조화된 로깅 + 메트릭

**상태**: 승인됨

**배경**: 시스템 성능과 사용자 행동에 대한 가시성이 필요합니다.

**결정**: 애플리케이션 메트릭과 함께 구조화된 로깅 구현

**근거**:
- **디버깅**: 구조화된 로그로 효율적인 문제 해결 가능
- **성능**: 스케줄링 알고리즘 성능 및 API 지연 시간 추적 메트릭
- **비즈니스 인텔리전스**: 기능 최적화를 위한 사용자 행동 분석
- **알림**: 시스템 문제의 사전 알림

**모니터링 영역**:
- API 응답 시간 및 오류율
- 스케줄링 알고리즘 실행 시간
- Google Calendar API 속도 제한 및 오류
- 데이터베이스 쿼리 성능
- 사용자 참여 메트릭

## 결론

이러한 아키텍처 결정들은 Google Calendar 연동을 통한 지능적인 할일 스케줄링 요구사항을 충족하는 견고하고 확장 가능한 시스템을 만듭니다. 선택된 기술과 패턴은 미래의 개선사항을 위한 견고한 기반을 제공하면서 유지보수성, 성능, 사용자 경험을 우선시합니다.