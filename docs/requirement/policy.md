# Todo Time-blocking 앱 정책 및 로직

## 🎯 스케줄링 알고리즘 (결정론적)

### 우선순위 정렬 로직
동일한 조건에서 항상 같은 결과가 나오도록 하기 위해 다음 순서로 Todo를 정렬합니다:

1. **놓친 할 일 최우선**: 시간을 놓친 할 일은 모든 다른 할 일보다 먼저 배치됩니다. 놓친 할 일에는 우선순위 +1 부스트가 자동 적용됩니다.

2. **데드라인 순서**: 마감일이 가까운 할 일부터 우선 배치합니다. 데드라인이 없는 할 일은 가장 낮은 우선순위로 처리됩니다.

3. **설정된 우선순위**: 사용자가 설정한 우선순위(높음/보통/낮음)에 따라 배치합니다. 높음은 1, 보통은 2, 낮음은 3의 값으로 처리됩니다.

4. **생성 시간**: 우선순위가 동일한 경우 먼저 만든 할 일이 우선됩니다.

5. **ID 순서**: 최종적으로 모든 조건이 같다면 ID가 작은 순서로 정렬합니다.

### 빈 시간 분석 알고리즘
Google Calendar와 연동하여 가용한 시간을 찾는 과정입니다:

1. **분석 범위 설정**: 현재 시점부터 해당 주의 금요일 오후 8시까지 설정 (예: 수요일 오후 3시 → 수 3시~8시, 목 10시~8시, 금 10시~8시)

2. **일정 수집**: Google Calendar에서 분석 범위 내 모든 기존 일정을 가져옵니다.

3. **업무시간 필터링**: 업무시간대(월~금 10AM-8PM)에서 기존 일정을 제외한 빈 시간만 추출합니다.

4. **시간 분할**: 30분 단위의 시간 슬롯으로 나누어 가용시간 매트릭스를 만듭니다.

5. **연속 시간 찾기**: 빈 시간 슬롯들 중에서 연속된 블록들을 찾아 크기순으로 정렬합니다.

6. **최소 시간 필터링**: 30분 이상의 연속 시간만 배치 가능한 시간으로 인정합니다.

7. **결과 반환**: 시작시간, 종료시간, 지속시간을 포함한 가용 시간 블록 목록을 반환합니다.

### Todo 분할 배치 로직
긴 시간이 소요되는 할 일을 여러 시간대에 나누어 배치하는 방법입니다:

1. **분할 필요성 판단**: 소요시간이 최대 연속 시간(기본 4시간)보다 긴 경우에만 분할합니다.

2. **분할 개수 계산**: 전체 소요시간을 최대 블록 크기로 나누어 필요한 분할 개수를 계산합니다.

3. **분할 Todo 생성**: 각 분할된 부분마다 별도의 Todo를 생성하고, "할 일명 (1/3)" 형태로 제목을 변경합니다.

4. **연결 관계 유지**: 원본 Todo와의 연결 관계를 parentId로 관리하고, 전체 분할 정보를 저장합니다.

### 배치 우선순위 알고리즘
정렬된 Todo들을 실제 시간에 배치하는 방식입니다:

1. **우선순위 순서대로 처리**: 앞서 정렬된 순서대로 각 Todo를 하나씩 처리합니다.

2. **테트리스 방식 배치**: 큰 시간 블록부터 우선적으로 사용하여 공간을 효율적으로 활용합니다.

3. **카테고리 인접 배치**: 같은 카테고리의 할 일들을 2시간 이내 간격으로 배치하려고 시도합니다.

4. **시간 슬롯 업데이트**: 할 일이 배치될 때마다 사용된 시간을 가용 시간에서 제외합니다.


## 📊 상태 전환 다이어그램 및 정책

```
대기중 ──[자동배치]──> 배치됨 ──[시작버튼]──> 진행중
  ↑                      │                      │
  │                      │                      │
  └──[수동이동]──────────┘                      │
                         │                      │
                    [30분 경과]            [완료버튼]
                         ↓                      ↓
                    놓친 할 일                 완료
                         │
                         └──[다시배치]──> 대기중
```

### 상태 전환 정책

#### 1. 놓친 할 일 처리
시간 기반으로 자동으로 할 일 상태를 변경하는 방식입니다:

- **자동 감지**: 시스템이 5분마다 배치된 할 일들을 확인합니다.
- **여유 시간 적용**: 할 일 종료 시간에서 30분의 여유시간을 두고 판단합니다.
- **상태 변경**: 여유시간이 지나도 시작하지 않은 할 일은 '놓친 할 일'로 자동 변경됩니다.
- **우선순위 부스트**: 놓친 할 일에는 다음 자동 배치 시 우선순위 +1 혜택이 적용됩니다.

#### 2. 우선순위 부스트 정책
놓친 할 일에 대한 특별 우선순위 적용 방식입니다:

- **부스트 적용**: 놓친 할 일의 경우 기존 우선순위에서 1단계 높여서 처리합니다.
- **최고 등급 제한**: 이미 '높음' 우선순위인 할 일도 최고 등급을 유지합니다.
- **재배치 우선권**: 부스트된 할 일은 일반 할 일보다 먼저 좋은 시간에 배치됩니다.

## 🔄 충돌 해결 로직

### Google Calendar 일정과의 충돌
외부 캘린더 일정과 겹치는 문제를 해결하는 방식입니다:

#### 충돌 감지
- **시간 겹침 검사**: Todo의 시작/종료 시간이 Google Calendar 일정과 겹치는지 확인합니다.
- **전체 일정 검토**: 배치하려는 시간대의 모든 Google Calendar 이벤트를 확인합니다.

#### 충돌 해결
- **충돌 발견**: 시간이 겹치는 일정이 있으면 충돌 정보와 대안 시간을 제안합니다.
- **자동 회피**: 충돌하는 시간을 피해 다음 가능한 시간을 자동으로 찾습니다.

### Todo 간 충돌 처리
같은 시간에 여러 할 일이 배치되려는 경우의 해결 방식입니다:

#### 우선순위 비교
- **충돌 할 일 찾기**: 같은 시간대에 이미 배치된 할 일들을 확인합니다.
- **우선순위 계산**: 놓친 할 일 부스트를 포함한 실제 우선순위를 비교합니다.

#### 재배치 결정
- **높은 우선순위 승리**: 더 중요한 할 일이 해당 시간을 차지하고, 낮은 우선순위 할 일은 다른 시간으로 이동합니다.
- **대안 시간 제안**: 밀려난 할 일을 위한 대체 가능한 시간대를 제안합니다.

## ⏰ 시간 관리 정책

### 업무시간대 설정
할 일 배치가 가능한 시간대를 정의하는 정책입니다:

- **시작 시간**: 오전 10시부터 배치 가능
- **종료 시간**: 오후 8시까지 배치 가능  
- **요일 제한**: 월요일부터 금요일까지만 자동 배치
- **시간대**: 한국 표준시(Asia/Seoul) 기준
- **주말 처리**: 토요일과 일요일은 기본적으로 배치하지 않음

### 시간 슬롯 단위 정책
시간을 나누고 정렬하는 기본 규칙입니다:

#### 시간 단위 설정
- **최소 단위**: 30분 단위로 모든 시간을 처리
- **최소 소요시간**: 할 일은 최소 30분 이상이어야 함
- **최대 연속시간**: 한 번에 최대 4시간까지 연속 배치
- **버퍼 시간**: 일정 사이에 15분의 여유 시간 확보

#### 시간 정렬 규칙
- **15분 미만**: 정각(00분)으로 조정
- **15-44분**: 30분으로 조정  
- **45분 이상**: 다음 시간 정각으로 조정
- **초/밀리초**: 모두 0으로 초기화

## 🏷️ 카테고리 및 태그 정책

### 카테고리 인접 배치 정책
같은 카테고리의 할 일들을 효율적으로 그룹핑하는 방식입니다:

#### 인접 배치 조건
- **시간 간격**: 같은 카테고리 할 일들을 2시간 이내 간격으로 배치 시도
- **보너스 점수**: 인접 배치가 가능한 경우 약간의 우선순위 보너스 제공
- **효율성 향상**: 비슷한 종류의 작업을 연속해서 처리하여 집중력 향상

#### 배치 우선권
- **업무 카테고리**: 오전~오후 시간대에 우선 배치
- **개인 카테고리**: 오후 늦은 시간이나 저녁 시간에 배치 선호

### 태그 기반 그룹핑
세부적인 작업 분류를 통한 효율적 일정 관리입니다:

#### 태그 그룹핑 로직
- **태그별 분류**: 동일한 태그를 가진 할 일들을 그룹으로 묶어서 처리
- **연관 배치**: 연관된 태그를 가진 할 일들을 같은 시간대에 배치 시도
- **컨텍스트 유지**: 비슷한 맥락의 작업들을 연속해서 처리

## 🔍 성능 및 제약사항

### 알고리즘 성능 목표
시스템이 목표로 하는 응답 시간과 처리 성능입니다:

- **빈 시간 분석**: 10초 이내 완료
- **충돌 감지**: 실시간 즉시 반응 (1s 이내)
- **상태 업데이트**: 5분마다 놓친 할 일 자동 체크

### 제약사항 및 한계
시스템이 처리할 수 있는 범위와 제한사항입니다:

#### 수량 제한
- **일일 할 일 수**: 하루 최대 20개까지 처리
- **분할 제한**: 하나의 할 일은 최대 5개 부분으로 분할

#### 시간 제한
- **최소 소요시간**: 30분 이상
- **최대 소요시간**: 8시간 이하
- **검증**: 이 범위를 벗어나는 할 일은 오류 메시지와 함께 거부

## 🚨 예외 처리 및 오류 복구

### 배치 실패 처리
자동 배치에 실패했을 때의 대안 전략들입니다:

#### 단계적 해결 전략
1. **업무시간 확장**: 오전 10시 이전이나 오후 8시 이후 시간 고려
2. **더 세분화**: 할 일을 더 작은 단위로 나누어 배치 시도
3. **우선순위 조정**: 낮은 우선순위 할 일을 밀어내고 배치
4. **수동 조정 요청**: 모든 자동 전략 실패 시 사용자에게 직접 조정 요청

#### 실패 알림
- **명확한 메시지**: "일부 할 일을 자동 배치할 수 없습니다. 수동으로 조정해 주세요."
- **실패 원인 제공**: 구체적인 배치 실패 이유 제시
- **대안 제안**: 가능한 해결 방법 안내

### 동기화 오류 복구
Google Calendar와의 연동 문제 발생 시 복구 방법입니다:

#### 오류 유형별 대응
- **API 제한 초과**: 캐시된 데이터를 임시로 사용하여 서비스 유지
- **네트워크 오류**: 오프라인 모드로 전환하여 로컬 데이터로 작업 
- **인증 오류**: 사용자에게 재로그인 요청
- **기타 오류**: 구체적인 오류 메시지와 함께 사용자에게 알림